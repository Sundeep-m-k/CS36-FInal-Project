# ---------------------------------------------------------------------------------------
# combine exp_xxx.csv (generated by point data) and residual gt box labels
# for CXR8, convert to trainable COCO json
# ---------------------------------------------------------------------------------------

import os
import csv
import json
from os import path

from pycocotools.coco import COCO
import numpy as np
import pandas as pd

# -------------------------------------- config -----------------------------------------

idx2class = {
    1: 'Aortic_enlargement',
    2: 'Cardiomegaly',
    3: 'Pulmonary_fibrosis',
    4: 'Pleural_thickening',
    5: 'Pleural_effusion',
    6: 'Lung_Opacity',
    7: 'Nodule_Mass',
    8: 'Others'
}

classname_to_id = {
    'Aortic_enlargement': 1,
    'Cardiomegaly': 2,
    'Pulmonary_fibrosis': 3,
    'Pleural_thickening': 4,
    'Pleural_effusion': 5,
    'Lung_Opacity': 6,
    'Nodule_Mass': 7,
    'Others': 8
}

# ========= CONFIG FOR CXR8 50p, EXP4 PBC TEACHER =========
partial = 50  # 50%

# CSV produced by main.py --generate_pseudo_bbox for CXR8, exp4, 50p
eval_csv_name = 'exp4_stage1_data50p_1pts_Erase0_jit005_unlabelLossL2Loss50_Load2ptsconsPth.csv'

# GT COCO for 50% CXR8 (only box)
coco_gt = '/home/sundeep/Point-Beyond-Class/data/cxr/ClsAll8_cocoAnnWBF/50p/instances_trainBox.json'

# CXR8 image dir (only used to match imgWH keys, not to read images)
image_dir = "/home/sundeep/Point-Beyond-Class/data/cxr/VinBigDataTrain_jpg/"

# FINAL OUTPUT FOLDER (like RSNA): put jsons here
saved_coco_path = "/home/sundeep/Point-Beyond-Class/data/cxr/gt_and_pseudo/"

# Path to the pseudo-label CSV
pseudo_labels = '/home/sundeep/Point-Beyond-Class/Output/outfiles/saveCsv_CXR8/' + eval_csv_name

# Intermediate CSV (GT + pseudo)
write_csv = os.path.join(
    '/home/sundeep/Point-Beyond-Class/Output/outfiles/saveCsv_CXR8/PseudoAndGtBox__' + eval_csv_name
)

# ---------------------------------------------------------------------------------------

# Quick sanity check: 50 from "data50p" must match partial
assert partial == int(eval_csv_name.split('data')[-1].split('p')[0]), \
    'ERROR: wrong file or wrong data proportion in filename.'

# Load GT COCO
coco = COCO(coco_gt)
ids = list(coco.imgs.keys())
total_num = len(ids)
unlabel_start_idx = int(total_num * partial / 100)

print('===> Supr. proportion: %d%%' % partial)
print('===> total imgs: ', total_num)
print('===> box-anns (GT imgs): ', unlabel_start_idx)
print('===> pseudo-anns (remaining imgs): ', total_num - unlabel_start_idx)

# ------------------------ build GT CSV part ------------------------
os.makedirs(os.path.dirname(write_csv), exist_ok=True)

with open(write_csv, 'w') as fw:
    csv_write = csv.writer(fw)
    for idx in range(unlabel_start_idx):
        anns = coco.loadAnns(coco.getAnnIds(ids[idx]))
        filename = coco.loadImgs(ids[idx])[0]["file_name"]
        for ann in anns:
            xmin, ymin, w, h = ann['bbox']
            xmin, ymin, xmax, ymax = xmin, ymin, xmin + w, ymin + h
            line = [filename] + list(map(str, [xmin, ymin, xmax, ymax])) + [idx2class[ann['category_id']]]
            csv_write.writerow(line)

# ------------------------ append pseudo csv to GT csv ------------------------
cmd = f"cat {pseudo_labels} >> {write_csv}"
os.system(cmd)

# ------------------------ load imgWH.txt ------------------------
with open('./imgWH.txt', 'r') as fr:
    lines = fr.readlines()
imgWH = {}
for line in lines:
    imgName, WH = line.strip().split(' ')
    imgWH[imgName] = WH  # 'xxx.jpg': '1024_1024'


class Csv2CoCo:
    def __init__(self, image_dir, total_annos):
        self.images = []
        self.annotations = []
        self.categories = []
        self.img_id = 0
        self.ann_id = 0
        self.image_dir = image_dir
        self.total_annos = total_annos

    def save_coco_json(self, instance, save_path):
        json.dump(instance, open(save_path, 'w'), ensure_ascii=False, indent=2)

    def to_coco(self, keys):
        self._init_categories()
        for key in keys:
            self.images.append(self._image(key))
            shapes = self.total_annos[key]
            for shape in shapes:
                bboxi = []
                for cor in shape[:-1]:
                    bboxi.append(int(cor))
                label = shape[-1]
                annotation = self._annotation(bboxi, label)
                self.annotations.append(annotation)
                self.ann_id += 1
            self.img_id += 1
        instance = {}
        instance['info'] = 'spytensor created'
        instance['license'] = ['license']
        instance['images'] = self.images
        instance['annotations'] = self.annotations
        instance['categories'] = self.categories
        return instance

    def _init_categories(self):
        for k, v in classname_to_id.items():
            category = {}
            category['id'] = v
            category['name'] = k
            self.categories.append(category)

    def _image(self, img_name):
        """
        img_name is like 'xxxxx.jpg', must exist in imgWH keys.
        """
        image = {}

        W, H = list(map(int, imgWH[img_name].split('_')))
        image['height'] = H
        image['width'] = W

        image['id'] = self.img_id
        image['file_name'] = img_name
        return image

    def _annotation(self, shape, label):
        points = shape[:4]
        annotation = {}
        annotation['id'] = self.ann_id
        annotation['image_id'] = self.img_id
        annotation['category_id'] = int(classname_to_id[label])
        annotation['segmentation'] = self._get_seg(points)
        annotation['bbox'] = self._get_box(points)
        annotation['iscrowd'] = 0
        annotation['area'] = self._get_area(points)
        return annotation

    def _get_box(self, points):
        min_x, min_y, max_x, max_y = points
        return [min_x, min_y, max_x - min_x, max_y - min_y]

    def _get_area(self, points):
        min_x, min_y, max_x, max_y = points
        return (max_x - min_x + 1) * (max_y - min_y + 1)

    def _get_seg(self, points):
        min_x, min_y, max_x, max_y = points
        h = max_y - min_y
        w = max_x - min_x
        a = [[
            min_x, min_y,
            min_x, min_y + 0.5 * h,
            min_x, max_y,
            min_x + 0.5 * w, max_y,
            max_x, max_y,
            max_x, max_y - 0.5 * h,
            max_x, min_y,
            max_x - 0.5 * w, min_y
        ]]
        return a


# ------------------------ csv2coco ------------------------

csv_file = write_csv

total_csv_annotations = {}
annotations = pd.read_csv(csv_file, header=None).values
for annotation in annotations:
    key = annotation[0].split(os.sep)[-1]  # image filename
    value = np.array([annotation[1:]])
    if key in total_csv_annotations:
        total_csv_annotations[key] = np.concatenate((total_csv_annotations[key], value), axis=0)
    else:
        total_csv_annotations[key] = value

train_box_keys = list(total_csv_annotations.keys())
print('===> total imgs in COCO      :', total_num)
print('===> imgs with at least 1 box:', len(train_box_keys))

# DO NOT assert here; CXR8 can have images with no GT/pseudo
# assert len(train_box_keys) == total_num, 'ERROR: [pseudo + gt] imgs count mismatch'

l2c_box_train = Csv2CoCo(image_dir=image_dir, total_annos=total_csv_annotations)
train_box_instance = l2c_box_train.to_coco(train_box_keys)

# Final filename in gt_and_pseudo (RSNA-style)
save_file = os.path.join(
    saved_coco_path,
    'train_LableBox_PseudoBox__' + eval_csv_name[:-4] + '.json'
)
l2c_box_train.save_coco_json(train_box_instance, save_file)

print('===> save json: ', save_file)
print('===> remove tmp .csv file: ', write_csv)
os.system('rm -f ' + write_csv)
print('done.')
